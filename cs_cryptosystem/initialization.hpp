#pragma once 
#include "sha256.h"
#include "multiply256.h"
#include <cstring>
#include <random>
#include <iostream>
#include <tuple>

#define SIZE_HASH 64 // in bytes
using namespace std;


/**
* Uniform distribution random number generator
* 
* See here -> https://ru.cppreference.com/w/cpp/numeric/random/uniform_real_distribution
*
* @param begin                                      Start of line
* @param end                                        End of line
*
* @return tuple (mt19937, iform_real_distribution)  Needed to generate numbers
*/
tuple<mt19937,uniform_real_distribution<>> generate_uniform_real_distribution(int begin,int end){
    std::random_device rd;
    return make_tuple(mt19937(rd()),uniform_real_distribution<> (begin, end)); 
}

/**
* Function generating the key k = (a, b), where a, b from GF (2 ^ n) is randomly selected
* !Memory is allocated!
*
* @return key Encryption key
 */
template <size_t n>
byte * generate_key() 
{
    const size_t key_length = n/4;
    auto key = new int[key_length];
    mt19937 rd;
    uniform_real_distribution urd;
    tie(rd,urd) = generate_uniform_real_distribution(0,10);
    
    for(size_t index = 0; index < key_length; ++index)
        key[index] = urd(rd);
    
        
    return (byte *)key;
};

/**
 * A function that generates a derivative key based on complicated Bose formulas (10)
 *! So far, it is not necessary to implement this method!
 *
 * @param key           Encryption key
 * @param init_vector   Initialization vector
 * @return              Derived_key Derived key generated by the shared key and initialization vector
 */
template <size_t n>
byte * create_complex_derived_key(const byte* key, const byte* init_vector) {
    
}

/**
 * The structure defines the initialization vector and the data associated with it
 * Must be stored: object counter, time stamp, attributes of the transmitted message
 * (Title, address of the sender / receiver, secrecy stamp, etc.)
 */
template <size_t n>
struct IV
{
    static int count_iv;
    string plain_text;

    IV(string text)
    {
        plain_text = text;
        count_iv++;
    };

    int get_count();
    byte* init_vector();
};


/**
 * Initialization vector counter
 */
template <size_t n>
int IV<n>::count_iv = 0;


/**
 * Get the serial number of the initialization vector
 */
template <size_t n>
int IV<n>::get_count()
{
    return count_iv;
}

/**
 * Function for "expanding" the hash in the case when the length of the initialization vector is more than 512 bits, which
 * we get sha256 output
 *
 * @param key       Initialization vector
 * @param length    Number of bytes filled in the initialization vector
 * @param deffir    The number of bytes to be filled with hashes
 */
void expand_init_vector(byte* key, const size_t length, const size_t differ)
{
    mt19937 rd;
    uniform_real_distribution urd;
    tie(rd,urd) = generate_uniform_real_distribution(0,10);

    for(size_t index = length; index < length + differ; index+=SIZE_HASH)
    {
        auto additional_hash =  sha256(to_string(urd(rd)));
        additional_hash.copy((char*)key + index,SIZE_HASH);
    }
}

/**
 * Method for creating the initialization vector vi = (a, b), where a, b from GF (2 ^ n)
 *! Memory is allocated!
 *
 * @return iv Initialization vector
 */
template<size_t n>
byte* IV<n>::init_vector()
{
    const string text_for_hash = plain_text + to_string(count_iv);
    const string hash = sha256(text_for_hash);

    //length of the initialization vector in bytes
    const size_t iv_lenght = n/4;
    byte* iv = new byte[iv_lenght + 1];
    const size_t length = hash.copy((char*)iv, iv_lenght);
    
    if(iv_lenght > SIZE_HASH)
    {
        const size_t differ = iv_lenght - SIZE_HASH;
        expand_init_vector(iv, length, differ);   
    }
    
    return iv;
}

/**
 * Function - XOR implementation of two byte arrays
 *
 * @param left_arr  Pointer to the beginning of the first number (byte array)
 * @param right_arr Pointer to the beginning of the second number
 * @return res      XOR of two byte arrays left_arr right_arr
 */
template<size_t n>
byte* xor_arrays(byte* left_arr, byte* right_arr)
{
    size_t length = n/8;
	byte* res = new byte[length]; 
	
	for(size_t index = 0; index < length; ++index)
	{
        char xor_left_right = left_arr[index] ^ right_arr[index];
        res[index] = xor_left_right;
    }
    
    return res;
}

/**
 * A function that generates a derivative key based on the Bowes formulas (8), (9)
 *
 * @param key           Encryption key
 * @param init_vector   Initialization vector
 * @return derived_key  Derived key generated by the shared key and initialization vector
 */
template <size_t n>
byte* create_derived_key(const byte* key, const byte* init_vector) {
    size_t length_derived_key = n/4;
    size_t length_part_derived_key = n/8;

    byte* iterative_derived_key = new byte[length_derived_key];

    byte* left_part_iterative_derived_key = new byte[length_part_derived_key];
    byte* right_part_iterative_derived_key = new byte[length_part_derived_key];

    byte* left_part_elementary_derived_key = new byte[length_part_derived_key];
    byte* right_part_elementary_derived_key = new byte[length_part_derived_key];

    byte* left_part_init_vector = new byte[length_part_derived_key];
    byte* right_part_init_vector = new byte[length_part_derived_key];

    memcpy(left_part_elementary_derived_key, key, length_part_derived_key);
    memcpy(right_part_elementary_derived_key, key + length_part_derived_key, length_part_derived_key);

    memcpy(left_part_init_vector, init_vector, length_part_derived_key);
    memcpy(right_part_init_vector, init_vector + length_part_derived_key, length_part_derived_key);

    left_part_iterative_derived_key = xor_arrays<n>(left_part_elementary_derived_key, left_part_init_vector);
    right_part_iterative_derived_key = xor_arrays<n>(right_part_elementary_derived_key, right_part_init_vector);

    left_part_iterative_derived_key = Multiply<n>(left_part_init_vector, left_part_iterative_derived_key);
    right_part_iterative_derived_key = Multiply<n>(right_part_init_vector, right_part_iterative_derived_key);

    left_part_iterative_derived_key = xor_arrays<n>(left_part_iterative_derived_key, right_part_init_vector);
    right_part_iterative_derived_key = xor_arrays<n>(right_part_iterative_derived_key, left_part_init_vector);

    memcpy(iterative_derived_key, left_part_iterative_derived_key, length_part_derived_key);
    memcpy(iterative_derived_key + length_part_derived_key, right_part_iterative_derived_key, length_part_derived_key);
   
    delete[] left_part_iterative_derived_key;
    delete[] right_part_iterative_derived_key;
    delete[] left_part_elementary_derived_key;
    delete[] right_part_elementary_derived_key;
    delete[] left_part_init_vector;
    delete[] right_part_init_vector;

    return iterative_derived_key;
}
