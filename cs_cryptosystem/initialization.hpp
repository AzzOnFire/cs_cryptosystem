#pragma once 

#include "defines.hpp"
#include "sha256.hpp"
#include "multiplication.hpp"

#define SIZE_HASH 64 // in bytes


/**
* Function generating the key k = (a, b), where a, b from GF (2 ^ n) are randomly selected
* !Memory is allocated!
*
* @return key Encryption key
 */
template <size_t n>
byte * generate_key() {
    const size_t key_size = 2 * n;

    byte * key = new byte[bits_to_bytes(key_size)];
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<uint64_t> dis(0, ULLONG_MAX);
    
    for(size_t i = 0; i < bits_to_qword(key_size); ++i){
        ((uint64_t *)key)[i] = dis(gen);
    }
    
    return key;
};

/**
 * A function that generates a derivative key based on complicated Bose formulas (10)
 *! So far, it is not necessary to implement this method!
 *
 * @param key           Encryption key
 * @param init_vector   Initialization vector
 * @return              Derived_key Derived key generated by the shared key and initialization vector
 */
template <size_t n>
byte * create_complex_derived_key(const byte* key, const byte* init_vector) {
    
}

/**
 * The structure defines the initialization vector and the data associated with it
 * Must be stored: object counter, time stamp, attributes of the transmitted message
 * (Title, address of the sender / receiver, secrecy stamp, etc.)
 */
// TODO struct must not contain any methods. And store plain_text is unnecessary
template <size_t n>
struct IV
{
    /*static int count_iv;
    string plain_text;

    IV(string text)
    {
        plain_text = text;
        count_iv++;
    };

    byte* init_vector();*/
};

/**
 * Function for "expanding" the hash in the case when the length of the initialization vector is more than 512 bits, which
 * we get sha256 output
 *
 * @param key       Initialization vector
 * @param length    Number of bytes filled in the initialization vector
 * @param deffir    The number of bytes to be filled with hashes
 */
template <size_t n>
void expand_init_vector(byte* key, const size_t length, const size_t differ) {

    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<uint64_t> dis(0, ULLONG_MAX);

    for(size_t i = length; i < length + differ; i+=SIZE_HASH)
    {
        auto additional_hash =  sha256(std::to_string(dis(gen)));
        additional_hash.copy((char*)key + i,SIZE_HASH);
    }
}

/**
 * Method for creating the initialization vector vi = (a, b), where a, b from GF (2 ^ n)
 *! Memory is allocated!
 *
 * @return iv Initialization vector
 */
/*
template<size_t n>
byte* IV<n>::init_vector() {
    const string text_for_hash = plain_text + to_string(count_iv);
    const string hash = sha256(text_for_hash);

    //length of the initialization vector in bytes
    const size_t iv_lenght = n/4;
    byte* iv = new byte[iv_lenght + 1];
    const size_t length = hash.copy((char*)iv, iv_lenght);
    
    if(iv_lenght > SIZE_HASH)
    {
        const size_t differ = iv_lenght - SIZE_HASH;
        expand_init_vector(iv, length, differ);   
    }
    
    return iv;
}
*/

/**
 * A function that generates a derivative key based on the Bowes formulas (8), (9)
 *
 * @param key           Encryption key
 * @param init_vector   Initialization vector
 * @return derived_key  Derived key generated by the shared key and initialization vector
 */
template <size_t n>
byte* create_derived_key(const byte* key, const byte* init_vector) {
    size_t length_derived_key = n/4;
    size_t length_part_derived_key = n/8;

    byte* iterative_derived_key = new byte[length_derived_key];

    // TODO create struct Derived Key. At least, make memory allocation only once, not six times
    // Code is unreadable
    byte* left_part_iterative_derived_key = new byte[length_part_derived_key];
    byte* right_part_iterative_derived_key = new byte[length_part_derived_key];

    byte* left_part_elementary_derived_key = new byte[length_part_derived_key];
    byte* right_part_elementary_derived_key = new byte[length_part_derived_key];

    byte* left_part_init_vector = new byte[length_part_derived_key];
    byte* right_part_init_vector = new byte[length_part_derived_key];

    memcpy(left_part_elementary_derived_key, key, length_part_derived_key);
    memcpy(right_part_elementary_derived_key, key + length_part_derived_key, length_part_derived_key);

    memcpy(left_part_init_vector, init_vector, length_part_derived_key);
    memcpy(right_part_init_vector, init_vector + length_part_derived_key, length_part_derived_key);
    /*
    left_part_iterative_derived_key = xor_arrays<n>(left_part_elementary_derived_key, left_part_init_vector);
    right_part_iterative_derived_key = xor_arrays<n>(right_part_elementary_derived_key, right_part_init_vector);

    left_part_iterative_derived_key = multiplication<n>(left_part_init_vector, left_part_iterative_derived_key);
    right_part_iterative_derived_key = multiplication<n>(right_part_init_vector, right_part_iterative_derived_key);

    left_part_iterative_derived_key = xor_arrays<n>(left_part_iterative_derived_key, right_part_init_vector);
    right_part_iterative_derived_key = xor_arrays<n>(right_part_iterative_derived_key, left_part_init_vector);
    */
    memcpy(iterative_derived_key, left_part_iterative_derived_key, length_part_derived_key);
    memcpy(iterative_derived_key + length_part_derived_key, right_part_iterative_derived_key, length_part_derived_key);
   
    delete[] left_part_iterative_derived_key;
    delete[] right_part_iterative_derived_key;
    delete[] left_part_elementary_derived_key;
    delete[] right_part_elementary_derived_key;
    delete[] left_part_init_vector;
    delete[] right_part_init_vector;

    return iterative_derived_key;
}
