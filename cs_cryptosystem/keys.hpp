#pragma once

#include <random>
#include "defines.hpp"
#include "multiplication.hpp"
#include "quasi.hpp"
#include "iv.hpp"


/**
 * Function g, generate derived key on key and iv
 *
 * @param key           Encryption key
 * @param iv   Initialization vector
 * @return derived_key  Derived key, generated by key and iv
 */
template <size_t n>
byte* g_function(byte* iv, const byte* key) {
    const byte* a_key = key;
    const byte* b_key = key + bits_to_bytes(n);

    byte* y_iv = iv;
    byte* d_iv = iv + bits_to_bytes(n);

    quasi<n>(y_iv, a_key);
    quasi<n>(d_iv, b_key);

    return iv;
}


/**
* Function generating the key k = (a, b), where a, b from GF (2 ^ n) are randomly distributed
*
* @return key Encryption key
 */
template <size_t n>
byte* create_key() {
    const size_t key_size = 2 * n;

    byte* key = new byte[bits_to_bytes(key_size)];
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<uint64_t> dis(0, ULLONG_MAX);

    for (size_t i = 0; i < bits_to_qword(key_size); ++i) {
        ((uint64_t*)key)[i] = dis(gen);
    }

    return key;
};


/**
 * A function that generates a derived key based on initialization vector and key
 *
 * @param key           Encryption key
 * @param iv            Initialization vector
 * @return derived_key  Derived key
 */
template <size_t n>
byte* create_derived_key(const byte* key, IV<n> * iv) {
    return g_function<n>((byte*)iv, key);
}
